package data

import (
	"encoding/json"
	"fmt"
)

// OxygenDataType indicates what the first byte of an OxygenData instance will
// be when marshalled into bytes for transmission.
const OxygenDataType byte = 2

// OxygenDataSize indicates the size of an OxygenData object when marshalled to
// bytes.
const OxygenDataSize = 10

// OxygenData represents the amount of oxygen in a first responder's air pack
// at a given point in time. It implements SensorData.
type OxygenData struct {

	// id indicates where this data point falls relative to all other data points
	// from the sensor.
	id byte

	// percentage indicates how full the first responder's air pack is.
	percentage float64
}

// CreateOxygenData will instantiate and return a new OxygenData objec with the
// given id, representing a measurement of the first responder's air pack that
// indicates it has the given percentage of oxygen remaining.
func CreateOxygenData(id byte, percentage float64) *OxygenData {
	return &OxygenData{
		id:         id,
		percentage: percentage,
	}
}

// Id indicates the sequence id of this element of data among all data points
// generated by this sensor, as defined by SensorData.
func (d *OxygenData) Id() byte {
	return d.id
}

// Type returns a value that uniquely identifies oxygen level sensors, as
// defined by SensorData.
func (d *OxygenData) Type() byte {
	return OxygenDataType
}

// String will return a string representation of the oxygen level measurement,
// as defined by fmt.Stringer.
func (d *OxygenData) String() string {
	return fmt.Sprintf("Oxygen [%d]: %f", d.id, d.percentage)
}

// NumBytes returns the number of bytes that an OxygenData object is marshalled
// to, as defined by SensorData.
func (u *OxygenData) NumBytes() int {
	return OxygenDataSize
}

// ToBytes will marshall this data point into a slice of bytes, which can be
// transmitted across the network, as defined by SensorData.
func (d *OxygenData) ToBytes() []byte {
	out := make([]byte, OxygenDataSize)
	idx := 0
	out[idx] = d.Type()
	idx++
	out[idx] = d.Id()
	idx++
	for _, b := range float64ToBytes(d.percentage) {
		out[idx] = b
		idx++
	}
	return out
}

// MarhsalJSON implements json.Marshaler, allowing for this data type to be
// converted to JSON easily.
func (d *OxygenData) MarshalJSON() ([]byte, error) {
	return json.Marshal(d.percentage)
}

// OxygenDataFromBytes takes the given input bytes and returns a new
// OxygenData object made from the data stored in the bytes.
func OxygenDataFromBytes(in []byte) SensorData {
	return &OxygenData{
		id:         in[1],
		percentage: bytesToFloat64(in[2:OxygenDataSize]),
	}
}
